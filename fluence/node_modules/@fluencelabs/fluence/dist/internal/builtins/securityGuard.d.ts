import { SecurityTetraplet } from '@fluencelabs/avm';
import { CallParams, PeerIdB58 } from '../commonTypes';
declare type ArgName = string | null;
/**
 * A predicate of call params for sig service's sign method which determines whether signing operation is allowed or not
 */
export declare type SecurityGuard<T extends ArgName> = (params: CallParams<T>) => boolean;
/**
 * Only allow calls when tetraplet for 'data' argument satisfies the predicate
 */
export declare const allowTetraplet: <T extends ArgName>(pred: (tetraplet: SecurityTetraplet) => boolean) => SecurityGuard<T>;
/**
 * Only allow data which comes from the specified serviceId and fnName
 */
export declare const allowServiceFn: <T extends ArgName>(serviceId: string, fnName: string) => SecurityGuard<T>;
/**
 * Only allow data originated from the specified json_path
 */
export declare const allowExactJsonPath: <T extends ArgName>(jsonPath: string) => SecurityGuard<T>;
/**
 * Only allow signing when particle is initiated at the specified peer
 */
export declare const allowOnlyParticleOriginatedAt: <T extends ArgName>(peerId: PeerIdB58) => SecurityGuard<T>;
/**
 * Only allow signing when all of the predicates are satisfied.
 * Useful for predicates reuse
 */
export declare const and: <T extends ArgName>(...predicates: SecurityGuard<T>[]) => SecurityGuard<T>;
/**
 * Only allow signing when any of the predicates are satisfied.
 * Useful for predicates reuse
 */
export declare const or: <T extends ArgName>(...predicates: SecurityGuard<T>[]) => SecurityGuard<T>;
export {};
//# sourceMappingURL=securityGuard.d.ts.map