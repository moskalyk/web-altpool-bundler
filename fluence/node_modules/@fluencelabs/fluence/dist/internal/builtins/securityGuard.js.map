{"version":3,"file":"securityGuard.js","sourceRoot":"","sources":["../../../src/internal/builtins/securityGuard.ts"],"names":[],"mappings":";;;AAUA;;GAEG;AACI,IAAM,cAAc,GAAG,UAC1B,IAA+C;IAE/C,OAAO,UAAC,MAAM;QACV,IAAM,CAAC,GAAG,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QACpC,OAAO,IAAI,CAAC,CAAC,CAAC,CAAC;IACnB,CAAC,CAAC;AACN,CAAC,CAAC;AAPW,QAAA,cAAc,kBAOzB;AAEF;;GAEG;AACI,IAAM,cAAc,GAAG,UAAoB,SAAiB,EAAE,MAAc;IAC/E,OAAO,IAAA,sBAAc,EAAC,UAAC,CAAC;QACpB,OAAO,CAAC,CAAC,UAAU,KAAK,SAAS,IAAI,CAAC,CAAC,aAAa,KAAK,MAAM,CAAC;IACpE,CAAC,CAAC,CAAC;AACP,CAAC,CAAC;AAJW,QAAA,cAAc,kBAIzB;AAEF;;GAEG;AACI,IAAM,kBAAkB,GAAG,UAAoB,QAAgB;IAClE,OAAO,IAAA,sBAAc,EAAC,UAAC,CAAC;QACpB,OAAO,CAAC,CAAC,SAAS,KAAK,QAAQ,CAAC;IACpC,CAAC,CAAC,CAAC;AACP,CAAC,CAAC;AAJW,QAAA,kBAAkB,sBAI7B;AAEF;;GAEG;AACI,IAAM,6BAA6B,GAAG,UAAoB,MAAiB;IAC9E,OAAO,UAAC,MAAM;QACV,OAAO,MAAM,CAAC,UAAU,KAAK,MAAM,CAAC;IACxC,CAAC,CAAC;AACN,CAAC,CAAC;AAJW,QAAA,6BAA6B,iCAIxC;AAEF;;;GAGG;AACI,IAAM,GAAG,GAAG;IAAoB,oBAAiC;SAAjC,UAAiC,EAAjC,qBAAiC,EAAjC,IAAiC;QAAjC,+BAAiC;;IACpE,OAAO,UAAC,MAAM,IAAK,OAAA,UAAU,CAAC,KAAK,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,CAAC,MAAM,CAAC,EAAT,CAAS,CAAC,EAAlC,CAAkC,CAAC;AAC1D,CAAC,CAAC;AAFW,QAAA,GAAG,OAEd;AAEF;;;GAGG;AACI,IAAM,EAAE,GAAG;IAAoB,oBAAiC;SAAjC,UAAiC,EAAjC,qBAAiC,EAAjC,IAAiC;QAAjC,+BAAiC;;IACnE,OAAO,UAAC,MAAM,IAAK,OAAA,UAAU,CAAC,IAAI,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,CAAC,MAAM,CAAC,EAAT,CAAS,CAAC,EAAjC,CAAiC,CAAC;AACzD,CAAC,CAAC;AAFW,QAAA,EAAE,MAEb","sourcesContent":["import { SecurityTetraplet } from '@fluencelabs/avm';\nimport { CallParams, PeerIdB58 } from '../commonTypes';\n\ntype ArgName = string | null;\n\n/**\n * A predicate of call params for sig service's sign method which determines whether signing operation is allowed or not\n */\nexport type SecurityGuard<T extends ArgName> = (params: CallParams<T>) => boolean;\n\n/**\n * Only allow calls when tetraplet for 'data' argument satisfies the predicate\n */\nexport const allowTetraplet = <T extends ArgName>(\n    pred: (tetraplet: SecurityTetraplet) => boolean,\n): SecurityGuard<T> => {\n    return (params) => {\n        const t = params.tetraplets.data[0];\n        return pred(t);\n    };\n};\n\n/**\n * Only allow data which comes from the specified serviceId and fnName\n */\nexport const allowServiceFn = <T extends ArgName>(serviceId: string, fnName: string): SecurityGuard<T> => {\n    return allowTetraplet((t) => {\n        return t.service_id === serviceId && t.function_name === fnName;\n    });\n};\n\n/**\n * Only allow data originated from the specified json_path\n */\nexport const allowExactJsonPath = <T extends ArgName>(jsonPath: string): SecurityGuard<T> => {\n    return allowTetraplet((t) => {\n        return t.json_path === jsonPath;\n    });\n};\n\n/**\n * Only allow signing when particle is initiated at the specified peer\n */\nexport const allowOnlyParticleOriginatedAt = <T extends ArgName>(peerId: PeerIdB58): SecurityGuard<T> => {\n    return (params) => {\n        return params.initPeerId === peerId;\n    };\n};\n\n/**\n * Only allow signing when all of the predicates are satisfied.\n * Useful for predicates reuse\n */\nexport const and = <T extends ArgName>(...predicates: SecurityGuard<T>[]): SecurityGuard<T> => {\n    return (params) => predicates.every((x) => x(params));\n};\n\n/**\n * Only allow signing when any of the predicates are satisfied.\n * Useful for predicates reuse\n */\nexport const or = <T extends ArgName>(...predicates: SecurityGuard<T>[]): SecurityGuard<T> => {\n    return (params) => predicates.some((x) => x(params));\n};\n"]}